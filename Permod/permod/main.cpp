#include "llvm/Pass.h"
#include "llvm/Passes/PassBuilder.h"
#include "llvm/Passes/PassPlugin.h"

#include "macker/LogManager.h"
#include "permod/ConditionAnalysis.hpp"
#include "permod/Instrumentation.hpp"
#include "permod/LogManager.h"
#include "permod/LogParser.h"
#include "utils/debug.h"

#include <queue>
#include <unordered_set>

using namespace llvm;

namespace {

/*
 * Find 'return -ERRNO'
    * The statement turns into:
    Error-thrower BB:
        store i32 -13ï¼Œptr %1, align 4
    Terminator BB:
        %2 = load i32, ptr %1, align 4
        ret i32 %2
 */
struct PermodPass : public PassInfoMixin<PermodPass> {
  /* // Uncomment this if you want to use ConditionPrinter
  // Use a pointer instead of direct member
  std::unique_ptr<ConditionPrinter> Printer;

  // Constructor initializes the pointer
  PermodPass() : Printer(std::make_unique<ConditionPrinter>()) {}
  */

  // Constructor
  PermodPass() = default;
  PermodPass(PermodPass &&) = default;
  PermodPass &operator=(PermodPass &&) = default;

  std::queue<unsigned> LineNumQueue;       // FIFO queue for LineNum
  std::unordered_set<unsigned> LineNumSet; // Set to track duplicates

  void traceValue(Value *V, int depth = 0) {
    if (!V)
      return;
    if (depth > 10)
      return; // Prevent infinite recursion

    if (auto *inst = dyn_cast<Instruction>(V)) {
      if (DebugLoc DL = inst->getDebugLoc()) {
        unsigned LineNum = DL->getLine();
        // print with depth
        DEBUG_PRINT2(std::string(depth * 2, ' ')
                     << "Line: " << LineNum << *V << "\n");

        if (LineNumSet.find(LineNum) == LineNumSet.end()) {
          // Add LineNum to FIFO if not already present
          LineNumQueue.push(LineNum);
          LineNumSet.insert(LineNum);
        }
      }
    }

    if (auto *icmp = dyn_cast<ICmpInst>(V)) {
      /* Trace each operands of cmp inst */
      traceValue(icmp->getOperand(0), depth + 1);
      traceValue(icmp->getOperand(1), depth + 1);
    } else if (auto *load = dyn_cast<LoadInst>(V)) {
      /* Find store inst for the pointer operand of the load inst */
      Value *ptr = load->getPointerOperand();
      findLastStore(ptr, *load->getFunction(), depth + 1);
    } else if (auto *call = dyn_cast<CallInst>(V)) {
      /* TODO: trace each argument */
      // errs() << std::string(depth * 2, ' ')
      //        << "Function call: " << call->getCalledFunction()->getName()
      //        << "\n";
    } else if (auto *binop = dyn_cast<BinaryOperator>(V)) {
      traceValue(binop->getOperand(0), depth + 1);
      traceValue(binop->getOperand(1), depth + 1);
    } else if (isa<Constant>(V)) {
      /* Do Nothing */
    }
  }

  void findLastStore(Value *ptr, Function &F, int depth) {
    for (auto &BB : F) {
      for (auto &I : BB) {
        if (auto *store = dyn_cast<StoreInst>(&I)) {
          if (store->getPointerOperand() == ptr) {
            traceValue(store->getValueOperand(), depth);
          }
        }
      }
    }
  }

  bool
  analyzeFunction(Function &F,
                  std::vector<macker::LogManager::LogEntry> &FunctionLogs) {
    // Extract debug info
    DebugInfo DBinfo;
    ReturnInst *RetI = findReturnInst(F);
    if (!RetI)
      return false;

    ConditionAnalysis::getDebugInfo(DBinfo, *RetI, F);

#if defined(KERNEL_MODE) && defined(DEBUG2)
    // Print IR
    if (F.getName() == "acl_permission_check") {
      // if (F.getName() == "may_open") {
      DEBUG_PRINT("Function: " << F.getName() << "\n");
      DEBUG_PRINT2(F << "\n");
    } else {
      return false;
    }
#endif

    // Perform instrumentation
    Instrumentation Ins(&F);
    long long CondID = 0;

    for (BasicBlock &BB : F) {
      Instruction *Term = BB.getTerminator();
      if (Term->getNumSuccessors() <= 1)
        continue;
      if (!Term->getDebugLoc())
        continue;
      // Skip if the terminator is generated by the compiler
      if (Term->getMetadata("nosanitize"))
        continue;

      // Init
      LineNumQueue = std::queue<unsigned>();
      LineNumSet.clear();

      std::string CondType;

      /*
        Check the order of sucessors, because it may be reversed by LLVM.
        e.g., `if(!x)`(x == 0 is True) is converted to `cmp ne i32 %x, 0`(False)
        Reversed if will be like `br i1 %cmp, label %if.else, label %if.then`,
        instead of `br i1 %cmp, label %if.then, label %if.else`.
        */
      if (auto *BrI = dyn_cast<BranchInst>(Term)) {
        if (BrI->isConditional()) {
          auto *Cond = BrI->getCondition();
          traceValue(Cond);
          CondType = "if";
          if (Term->getSuccessor(1)->getName().starts_with("if.then")) {
            CondType = "if-reverse";
          }
        }
      } else if (auto *SI = dyn_cast<SwitchInst>(Term)) {
        CondType = "switch";
      } else {
        continue;
      }

      unsigned LineNum = 0;
      if (DebugLoc DL = Term->getDebugLoc()) {
        LineNum = DL.getLine();
      }

      // Print the condition
      std::string LineNumStr;
      while (!LineNumQueue.empty()) {
        unsigned LineNum = LineNumQueue.front();
        LineNumQueue.pop();
        LineNumStr += std::to_string(LineNum) + ",";
      }
      if (!LineNumStr.empty()) {
        LineNumStr.pop_back(); // Remove the trailing comma
      }
      DEBUG_PRINT2("LineNum: " << LineNumStr << "\n");

      LogManager::getInstance().addEntry(DBinfo.first,
                                         LineNum,
                                         DBinfo.second,
                                         CondType,
                                         CondID,
                                         LineNumStr,
                                         "");

      // Add instrumentation
      if (Ins.insertBufferFunc(BB, DBinfo, CondID)) {
        CondID++;
        DEBUG_PRINT2("Inserted at " << BB.getName() << "\n");
        DEBUG_PRINT2(BB << "\n");
      }
    }

    return Ins.insertFlushFunc(DBinfo, *RetI->getParent());
  }

  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM) {
    // Filter modules
    if (!shouldProcessModule(M))
      return PreservedAnalyses::all();

    // Parse Macker Logs
    LogParser parser("macker_logs.csv");
    parser.parse();
    const auto &logs = parser.getParsedLogs();

    bool Modified = false;
    for (auto &F : M.functions()) {
      if (shouldProcessFunction(F)) {
        // Filter logs for the current function
        std::vector<macker::LogManager::LogEntry> FunctionLogs;
        for (const auto &log : logs) {
          if (log.FunctionName == F.getName()) {
            FunctionLogs.push_back(log);
          }
        }

        // Process the function with its logs
        Modified |= analyzeFunction(F, FunctionLogs);
      }
    }

    DEBUG_PRINT2("Permod: Finished analyzing functions.\n");
    DEBUG_PRINT2("Permod: Writing logs to CSV file...\n");
    DEBUG_PRINT2("Permod: File: " << M.getName() << "\n");
    // Write all logs to a CSV file
    LogManager::getInstance().writeAllLogs();

    return Modified ? PreservedAnalyses::none() : PreservedAnalyses::all();
  }

  // Helper methods
  bool shouldProcessModule(Module &M) {
#if defined(KERNEL_MODE)
    return M.getName().find("fs/") != std::string::npos;
#else
    return true;
#endif
  }

  bool shouldProcessFunction(Function &F) {
    // clang-format off
    return !F.isDeclaration() && 
           !F.getName().startswith("llvm") &&
           F.getName() != LOGGR_FUNC && 
           F.getName() != BUFFR_FUNC &&
           F.getName() != FLUSH_FUNC;
    // clang-format on
  }

  ReturnInst *findReturnInst(Function &F) {
    for (auto &BB : F) {
      if (auto *RI = dyn_cast_or_null<ReturnInst>(BB.getTerminator())) {
        return RI;
      }
    }
    return nullptr;
  }
};
} // namespace

extern "C" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo
llvmGetPassPluginInfo() {
  return {.APIVersion = LLVM_PLUGIN_API_VERSION,
          .PluginName = "Permod pass",
          .PluginVersion = "v0.1",
          .RegisterPassBuilderCallbacks = [](PassBuilder &PB) {
            PB.registerPipelineStartEPCallback(
                [](ModulePassManager &MPM, OptimizationLevel Level) {
                  MPM.addPass(PermodPass());
                });
          }};
}
